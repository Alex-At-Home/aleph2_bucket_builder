[
  {
    "display_name": "Bucket Metadata",
    "form_info": "General bucket parameters",
    "expandable": false,
    "key": "data_bucket",
    "categories": [
      "Metadata"
    ],
    "filters": [
      "Bucket"
    ],
    "schema": [
      {
        "key": "full_name",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Bucket Path",
          "placeholder": "The virtual bucket path, eg /path/to/bucket",
          "required": true
        }
      },
      {
        "key": "poll_frequency",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Poll Frequency",
          "placeholder": "Human readable frequency (eg '10min', '1 day') for how often this harvester is polled",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "show_test_settings",
        "type": "checkbox",
        "templateOptions": {
          "label": "Show Test Settings"
        }
      },
      {
        "key": "requested_num_objects",
        "hideExpression": "!model.show_test_settings",
        "type": "horizontalInput",
        "defaultValue": "100",
        "templateOptions": {
          "pattern": "[0-9]+",
          "label": "Requested Data Objects",
          "placeholder": "The desired number of data objects to be returned by the test",
          "required": true
        }
      },
      {
        "key": "max_startup_time_secs",
        "hideExpression": "!model.show_test_settings",
        "type": "horizontalInput",
        "defaultValue": "60",
        "templateOptions": {
          "pattern": "[0-9]+",
          "label": "Max Startup Time (s)",
          "placeholder": "The maximum number of seconds to wait for the test to startup",
          "required": true
        }
      },
      {
        "key": "max_run_time_secs",
        "hideExpression": "!model.show_test_settings",
        "type": "horizontalInput",
        "defaultValue": "120",
        "templateOptions": {
          "pattern": "[0-9]+",
          "label": "Max Run Time (s)",
          "placeholder": "The maximum number of seconds to wait for the test to run, after it has started up",
          "required": true
        }
      },
      {
        "key": "max_storage_time_secs",
        "hideExpression": "!model.show_test_settings",
        "type": "horizontalInput",
        "defaultValue": "86400",
        "templateOptions": {
          "pattern": "[0-9]+",
          "label": "Max Test Storage Time (s)",
          "placeholder": "The maximum time (secs) to keep the test result data",
          "required": false
        }
      },
      {
        "key": "overwrite_existing_data",
        "hideExpression": "!model.show_test_settings",
        "type": "horizontalCheckbox",
        "defaultValue": true,
        "templateOptions": {
          "label": "Overwrite existing data",
          "required": false
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  curr_obj.full_name = template.element.form_model.full_name;\n    \tvar pf = template.element.form_model.poll_frequency; \n  curr_obj.poll_frequency = (pf || '').length > 0 ? pf : undefined; \t\tif (template.element.form_model.requested_num_objects) { curr_obj.test_params = {};\n\t\tvar doc = curr_obj.test_params;\n\t\tdoc.requested_num_objects = parseInt(template.element.form_model.requested_num_objects);\n\t\tdoc.max_startup_time_secs = parseInt(template.element.form_model.max_startup_time_secs);\n\t\tdoc.max_run_time_secs = parseInt(template.element.form_model.max_run_time_secs);\n\t\tif ((template.element.form_model.max_storage_time_secs || '').length > 0) doc.max_storage_time_secs = parseInt(template.element.form_model.max_storage_time_secs);\n\t\tdoc.overwrite_existing_data = template.element.form_model.overwrite_existing_data; }\n\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Generic Harvester",
    "form_info": "For advanced users: create an empty Harvester Config that users can build with the form; and configure by writing raw JSON",
    "expandable": false,
    "key": "harvest_engine",
    "categories": [
      "Harvester"
    ],
    "filters": [
      "Bucket"
    ],
    "schema": [
      {
        "key": "harvest_technology_name_or_id",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Technology Library Name",
          "placeholder": "The path to the technology, eg /app/aleph2/library/harvester.jar",
          "required": true
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "show_advanced",
        "type": "checkbox",
        "templateOptions": {
          "label": "Show Advanced Options"
        }
      },
      {
        "key": "module_name_or_id",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Technology Module Name",
          "placeholder": "For harvesters with pluggable modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
          "required": false
        }
      },
      {
        "key": "entry_point",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Entry Point Override",
          "placeholder": "For harvest modules with multiple entry points, specifies the JVM class to execute, eg com.ikanow.aleph2.harvest.module.Module1EntryPoint",
          "required": false
        }
      },
      {
        "key": "library_names_or_ids",
        "type": "multiInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Additional Library Modules",
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "label": "Technology Module Name",
              "placeholder": "For harvesters that need additional library modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
              "required": false
            }
          }
        }
      },
      {
        "key": "node_list_rules",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Node rules",
          "placeholder": "Comma-separated list of rules determining on which nodes this harvester will run",
          "required": false
        }
      },
      {
        "key": "multi_node_enabled",
        "type": "horizontalCheckbox",
        "defaultValue": false,
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Harvester multi-node enabled",
          "required": false
        }
      },
      {
        "key": "lock_to_nodes",
        "type": "horizontalCheckbox",
        "defaultValue": true,
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Lock harvester to the same node/set of nodes (recommend leave as true)",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "config",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Harvest Configuration JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n   curr_obj.harvest_technology_name_or_id = template.element.form_model.harvest_technology_name_or_id; \n  curr_obj.node_list_rules = a2_optional_array_from_csv(template.element.form_model.node_list_rules);\n\t  curr_obj.multi_node_enabled = template.element.form_model.multi_node_enabled;\n  curr_obj.lock_to_nodes = template.element.form_model.lock_to_nodes;\n  curr_obj.harvest_configs = [\n    {\n      module_name_or_id: template.element.form_model.module_name_or_id, \n      library_names_or_ids: template.element.form_model.library_names_or_ids,\n      entry_point: template.element.form_model.entry_point, \n      config: JSON.parse(template.element.form_model.config || '{}') \n    }]; \n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Batch Enrichment Pipeline",
    "form_info": "<p>This is a container for a batch enrichment pipeline that will transform incoming objects before writing them into the bucket output.</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n",
    "expandable": true,
    "key": "enrichment_engine",
    "categories": [
      "Enrichment"
    ],
    "filters": [
      "Bucket"
    ],
    "child_filters": [
      "batch_enrichment_meta",
      "enrichment_meta"
    ],
    "schema": [
      {
        "key": "external_emit_paths",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Allowed external output paths",
          "placeholder": "Comma-separated list of paths/globs to which the bucket is allowed to 'externalEmit'",
          "required": false
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.external_emit_paths = a2_optional_array_from_csv(template.element.form_model.external_emit_paths);curr_obj.master_enrichment_type = 'batch'; curr_obj.batch_enrichment_configs = []; return curr_obj.batch_enrichment_configs; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Streaming Enrichment Topology",
    "form_info": "<p>This is a container for a streaming enrichment engine that will transform incoming objects before writing them into the bucket output.</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n",
    "expandable": true,
    "key": "enrichment_engine",
    "categories": [
      "Enrichment"
    ],
    "filters": [
      "Bucket"
    ],
    "child_filters": [
      "stream_enrichment_meta",
      "enrichment_meta"
    ],
    "schema": [
      {
        "key": "external_emit_paths",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Allowed external output paths",
          "placeholder": "Comma-separated list of paths/globs to which the bucket is allowed to 'externalEmit'",
          "required": false
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.external_emit_paths = a2_optional_array_from_csv(template.element.form_model.external_emit_paths);\n curr_obj.master_enrichment_type = 'streaming'; curr_obj.streaming_enrichment_topology = {}; return curr_obj.streaming_enrichment_topology; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Enrichment Element",
    "form_info": "For advanced users: create an empty document schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": false,
    "key": "enrichment_meta",
    "categories": [
      "Generic"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "element",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Enrichment Element JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { var obj = JSON.parse(template.element.form_model.element || '{}'); a2_inject_enrichment(curr_obj, obj); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Analytic Thread Container",
    "form_info": "<p>This is a container for the analytic jobs that fill the bucket with data</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n",
    "expandable": true,
    "key": "analytic_thread",
    "categories": [
      "Analytics"
    ],
    "filters": [
      "Bucket"
    ],
    "child_filters": [
      "analytic_job",
      "analytic_trigger"
    ],
    "schema": [
      {
        "key": "external_emit_paths",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Allowed external output paths",
          "placeholder": "Comma-separated list of paths/globs to which the bucket is allowed to 'externalEmit'",
          "required": false
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.external_emit_paths = a2_optional_array_from_csv(template.element.form_model.external_emit_paths); curr_obj.analytic_thread = { jobs: [] }; return curr_obj.analytic_thread; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Generic Analytic Job",
    "form_info": "A streaming or batch analytic job that performs processing on input or stored data. ",
    "expandable": true,
    "key": "analytic_job",
    "categories": [
      "Generic Processing"
    ],
    "filters": [
      "Bucket/**"
    ],
    "child_filters": [
      "analytic_input",
      "analytic_output"
    ],
    "schema": [
      {
        "key": "_short_name",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Unique Job Name",
          "pattern": "[a-zA-Z0-9_]+",
          "placeholder": "A Short Name For This Element (Alphanumeric/_ only, no spaces - used for dependencies etc)",
          "required": true
        }
      },
      {
        "key": "analytic_type",
        "type": "horizontalSelect",
        "templateOptions": {
          "required": true,
          "label": "Analytic Type",
          "options": [
            {
              "name": "Batch",
              "value": "batch"
            },
            {
              "name": "Streaming",
              "value": "streaming"
            }
          ]
        }
      },
      {
        "key": "dependencies",
        "type": "horizontalInput",
        "hideExpression": "model.analytic_type !== \"batch\"",
        "templateOptions": {
          "label": "Dependencies",
          "placeholder": "A comma-separated list of dependencies on other analytic jobs",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "analytic_technology_name_or_id",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Technology Library Name",
          "placeholder": "The path to the technology, eg /app/aleph2/library/analytic_technology.jar",
          "required": true
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "show_advanced",
        "type": "checkbox",
        "templateOptions": {
          "label": "Show Advanced Options"
        }
      },
      {
        "key": "module_name_or_id",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Technology Module Name",
          "placeholder": "For analytic technologies with pluggable modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
          "required": false
        }
      },
      {
        "key": "entry_point",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Entry Point Override",
          "placeholder": "For analytics modules with multiple entry points, specifies the JVM class to execute, eg com.ikanow.aleph2.harvest.module.Module1EntryPoint",
          "required": false
        }
      },
      {
        "key": "library_names_or_ids",
        "type": "multiInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Additional Library Modules",
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "label": "Technology Module Name",
              "placeholder": "For analytics that need additional library modules, the path to the module, eg /app/aleph2/library/analytic_module_lib.jar",
              "required": false
            }
          }
        }
      },
      {
        "key": "node_list_rules",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Node rules",
          "placeholder": "Comma-separated list of rules determining on which nodes this analytic job will run",
          "required": false
        }
      },
      {
        "key": "lock_to_nodes",
        "type": "horizontalCheckbox",
        "defaultValue": false,
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Lock analytic job to the same node/set of nodes (recommend leave as false)",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "config",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Analytic Job Configuration JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  var new_obj = { inputs: [] };\n  new_obj.name = template.element.short_name; new_obj.lock_to_nodes = template.element.form_model.lock_to_nodes; new_obj.analytic_type = template.element.form_model.analytic_type; \n  new_obj.dependencies = a2_optional_array_from_csv(template.element.form_model.dependencies);\n  new_obj.analytic_technology_name_or_id = template.element.form_model.analytic_technology_name_or_id; \n  new_obj.module_name_or_id = template.element.form_model.module_name_or_id; \n  new_obj.entry_point = template.element.form_model.entry_point; \n  new_obj.library_names_or_ids = template.element.form_model.library_names_or_ids; \n  new_obj.node_list_rules = a2_optional_array_from_csv(template.element.form_model.node_list_rules);\n  new_obj.config = JSON.parse(template.element.form_model.config || '{}'); \n  curr_obj.jobs.push(new_obj);\n  return new_obj;\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Batch Enrichment Pipeline",
    "form_info": "A batch analytic job that uses the batch enrichment engine to perform processing on input or stored data. ",
    "expandable": true,
    "key": "analytic_job",
    "categories": [
      "Generic Processing"
    ],
    "filters": [
      "Bucket/**"
    ],
    "child_filters": [
      "analytic_input",
      "analytic_output",
      "enrichment_meta",
      "batch_enrichment_meta"
    ],
    "schema": [
      {
        "key": "_short_name",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Unique Job Name",
          "pattern": "[a-zA-Z0-9_]+",
          "placeholder": "A Short Name For This Element (Alphanumeric/_ only, no spaces - used for dependencies etc)",
          "required": true
        }
      },
      {
        "key": "dependencies",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Dependencies",
          "placeholder": "A comma-separated list of dependencies on other analytic jobs",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "module_name_or_id",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Technology Module Name",
          "placeholder": "For enrichment engines with pluggable modules, the path to the module, eg /app/aleph2/library/batch_enrichment_module.jar",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "show_advanced",
        "type": "checkbox",
        "templateOptions": {
          "label": "Show Advanced Options"
        }
      },
      {
        "key": "library_names_or_ids",
        "type": "multiInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Additional Library Modules",
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "label": "Technology Module Name",
              "placeholder": "For enrichment engines that need additional library modules, the path to the module, eg /app/aleph2/library/enrichment_module_lib.jar",
              "required": false
            }
          }
        }
      },
      {
        "key": "node_list_rules",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Node rules",
          "placeholder": "Comma-separated list of rules determining on which nodes this analytic job will run",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  var new_obj = { inputs: [] };\n  new_obj.name = template.element.short_name; new_obj.analytic_type = 'batch'; \n  new_obj.dependencies = a2_optional_array_from_csv(template.element.form_model.dependencies);\n  new_obj.analytic_technology_name_or_id = 'BatchEnrichmentService'; \n  new_obj.module_name_or_id = template.element.form_model.module_name_or_id; \n  new_obj.library_names_or_ids = template.element.form_model.library_names_or_ids; \n  new_obj.node_list_rules = a2_optional_array_from_csv(template.element.form_model.node_list_rules);\n  new_obj.config = { 'enrich_pipeline': [] }; \n  curr_obj.jobs.push(new_obj);\n  return new_obj;\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {var lib_map = {}; var curr_job = curr_obj.jobs[curr_obj.jobs.length-1]; for ( var e in curr_job.config.enrich_pipeline ) { for ( l in curr_job.config.enrich_pipeline[e].library_names_or_ids ) { lib_map[curr_job.config.enrich_pipeline[e].library_names_or_ids[l]] = true;}} curr_job.library_names_or_ids = []; var libs = (template.element.form_model.library_names_or_ids || []); for (var kk in libs) curr_job.library_names_or_ids.push(libs[kk]); for (var k in lib_map) curr_job.library_names_or_ids.push(k); }"
    }
  },
  {
    "display_name": "Streaming Enrichment Topology",
    "form_info": "A streaming analytic job that uses the streaming enrichment engine to perform processing on input or stored data. ",
    "expandable": true,
    "key": "analytic_job",
    "categories": [
      "Generic Processing"
    ],
    "filters": [
      "Bucket/analytic_thread"
    ],
    "child_filters": [
      "analytic_input",
      "analytic_output",
      "enrichment_meta",
      "stream_enrichment_meta"
    ],
    "schema": [
      {
        "key": "_short_name",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Unique Job Name",
          "pattern": "[a-zA-Z0-9_]+",
          "placeholder": "A Short Name For This Element (Alphanumeric/_ only, no spaces - used for dependencies etc)",
          "required": true
        }
      },
      {
        "key": "module_name_or_id",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Technology Module Name",
          "placeholder": "For enrichment engines with pluggable modules, the path to the module, eg /app/aleph2/library/streaming_enrichment_module.jar",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "show_advanced",
        "type": "checkbox",
        "templateOptions": {
          "label": "Show Advanced Options"
        }
      },
      {
        "key": "library_names_or_ids",
        "hideExpression": "!model.show_advanced",
        "type": "multiInput",
        "templateOptions": {
          "label": "Additional Library Modules",
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "label": "Technology Module Name",
              "placeholder": "For analytics that need additional library modules, the path to the module, eg /app/aleph2/library/analytic_module_lib.jar",
              "required": false
            }
          }
        }
      },
      {
        "key": "node_list_rules",
        "type": "horizontalInput",
        "hideExpression": "!model.show_advanced",
        "templateOptions": {
          "label": "Node rules",
          "placeholder": "Comma-separated list of rules determining on which nodes this analytic job will run",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  var new_obj = { inputs: [] };\n  new_obj.name = template.element.short_name; new_obj.analytic_type = 'streaming'; \n  \tnew_obj.analytic_technology_name_or_id = 'StreamingEnrichmentService'; \n  new_obj.module_name_or_id = template.element.form_model.module_name_or_id; \n  new_obj.library_names_or_ids = template.element.form_model.library_names_or_ids; \n  new_obj.node_list_rules = a2_optional_array_from_csv(template.element.form_model.node_list_rules);\n  new_obj.config = { }; \n  curr_obj.jobs.push(new_obj);\n  return new_obj;\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Analytic Trigger",
    "form_info": "For advanced users: create an empty trigger JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": false,
    "key": "analytic_trigger",
    "categories": [
      "Scheduling"
    ],
    "filters": [
      "Bucket/analytic_thread"
    ],
    "schema": [
      {
        "key": "schedule",
        "type": "horizontalInput",
        "templateOptions": {
          "label": "Trigger Check Schedule",
          "placeholder": "Human readable frequency (eg '10min', '1 day') for how often this harvester is polled",
          "required": false
        }
      },
      {
        "template": "<hr/>"
      },
      {
        "key": "trigger",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Analytic Thread Trigger JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.trigger_config = JSON.parse(template.element.form_model.trigger || '{}'); var pf = template.element.form_model.schedule; curr_obj.trigger_config.schedule = (pf || '').length > 0 ? pf : undefined; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Global Input Config",
    "form_info": "Empty JSON object used to configure the global default input configuration for all inputs in this analytic job\n",
    "expandable": false,
    "key": "analytic_input",
    "categories": [
      "Input"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "global_input_config",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Analytic Global Input Configuration JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.global_input_config = JSON.parse(template.element.form_model.global_input_config || '{}'); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Analytic Input",
    "form_info": "Empty JSON object used to configure an input for this analytic job\n",
    "expandable": false,
    "key": "analytic_input",
    "categories": [
      "Input"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "input",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Analytic Input JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.inputs.push(JSON.parse(template.element.form_model.input || '{}')); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Analytic Output",
    "form_info": "Empty JSON object used to configure a single output for this analytic job\n",
    "expandable": false,
    "key": "analytic_output",
    "categories": [
      "Output"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "output",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Analytic Output JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.output = JSON.parse(template.element.form_model.output || '{}'); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Data Schema Container",
    "form_info": "<p>This is a container for the data schema for the different attributes of the stored data</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n",
    "expandable": true,
    "key": "data_schema",
    "categories": [
      "Metadata"
    ],
    "filters": [
      "Bucket"
    ],
    "child_filters": [
      "data_service_schema"
    ],
    "schema": [],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.data_schema = {}; return curr_obj.data_schema; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Search Index Schema",
    "form_info": "For advanced users: create an empty search index schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": false,
    "key": "data_service_schema",
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "schema",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Search Index Schema JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.search_index_schema = JSON.parse(template.element.form_model.schema || '{}'); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Temporal Schema",
    "form_info": "For advanced users: create an empty temporal schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": false,
    "key": "data_service_schema",
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "schema",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Temporal Schema JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.temporal_schema = JSON.parse(template.element.form_model.schema || '{}'); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Columnar Schema",
    "form_info": "For advanced users: create an empty columnar schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": false,
    "key": "data_service_schema",
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "schema",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Columnar Schema JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.columnar_schema = JSON.parse(template.element.form_model.schema || '{}'); }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Storage Schema",
    "form_info": "For advanced users: create an empty storage schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": true,
    "key": "data_service_schema",
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "schema": [
      {
        "key": "schema",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Storage Schema JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.storage_schema = JSON.parse(template.element.form_model.schema || '{}'); return curr_obj.storage_schema; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Raw JSON Document Schema",
    "form_info": "For advanced users: create an empty document schema JSON object that can be Raw JSON to provide the desired functionality\n",
    "expandable": true,
    "key": "data_service_schema",
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "child_filters": [
      "enrichment_meta"
    ],
    "schema": [
      {
        "key": "schema",
        "type": "code_input",
        "defaultValue": "{\n}",
        "templateOptions": {
          "label": "Document Schema JSON",
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          }
        }
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.document_schema = JSON.parse(template.element.form_model.schema || '{}'); curr_obj.document_schema.custom_deduplication_configs = []; return curr_obj.document_schema.custom_deduplication_configs; }"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Document Schema",
    "form_info": "Configures the document service (supporting deduplication)",
    "expandable": true,
    "key": "data_service_schema",
    "sub_keys": [
      "document_schema"
    ],
    "categories": [
      "Schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "child_filters": [
      "batch_enrichment_meta",
      "enrichment_meta"
    ],
    "schema": [
      {
        "templateOptions": {
          "required": true,
          "label": "Deduplication Policy",
          "options": [
            {
              "name": "Leave existing objects",
              "value": "leave"
            },
            {
              "name": "Overwrite with newer objects, else leave",
              "value": "update"
            },
            {
              "name": "Overwrite existing objects",
              "value": "overwrite"
            },
            {
              "name": "Merge incoming and existing objects",
              "value": "custom"
            },
            {
              "name": "Merge newer incoming and existing objects",
              "value": "custom_update"
            }
          ]
        },
        "type": "horizontalSelect",
        "key": "deduplication_policy"
      },
      {
        "type": "multiInput",
        "templateOptions": {
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "placeholder": "The list of fields over which to deduplicate"
            }
          },
          "label": "Deduplication Fields"
        },
        "key": "deduplication_fields"
      },
      {
        "type": "multiInput",
        "templateOptions": {
          "inputOptions": {
            "type": "input",
            "templateOptions": {
              "placeholder": "A list of bucket paths/globs to which to apply the deduplication"
            }
          },
          "label": "Deduplication Contexts"
        },
        "key": "deduplication_contexts"
      },
      {
        "templateOptions": {
          "label": "Finalize all object sets with custom enrichment step, singletons and duplicates",
          "placeholder": "If true (default: false) then all objects are run through the custom dedup (ie acting as a \"finalize\" step before emitting when there is no matching dedup)"
        },
        "type": "checkbox",
        "key": "custom_finalize_all_objects"
      },
      {
        "key": "technology_override_schema",
        "type": "code_input",
        "templateOptions": {
          "codemirror": {
            "lineNumbers": true,
            "smartIndent": true,
            "mode": "javascript"
          },
          "label": "Technology Override Schema"
        }
      }
    ],
    "default_model": {
      "deduplication_timing": "custom",
      "deduplication_policy": "leave",
      "deduplication_fields": [],
      "deduplication_contexts": [],
      "custom_deduplication_configs": [],
      "custom_finalize_all_objects": false,
      "technology_override_schema": "{\n\t\n}"
    },
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  curr_obj.document_schema = {};\n  curr_obj.document_schema.enabled = true;\n  curr_obj.document_schema.deduplication_timing = template.element.form_model.deduplication_timing;\n  curr_obj.document_schema.deduplication_policy = template.element.form_model.deduplication_policy;\n  curr_obj.document_schema.deduplication_fields = template.element.form_model.deduplication_fields;\n  curr_obj.document_schema.deduplication_contexts = template.element.form_model.deduplication_contexts;\n  curr_obj.document_schema.custom_deduplication_configs = [];\n  curr_obj.document_schema.custom_finalize_all_objects = template.element.form_model.custom_finalize_all_objects;\n  curr_obj.document_schema.technology_override_schema = JSON.parse(template.element.form_model.technology_override_schema);\n  return curr_obj.document_schema.custom_deduplication_configs;\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n}"
    }
  },
  {
    "display_name": "Deduplication Service",
    "form_info": "An enrichment engine providing deduplication and lookup functionality",
    "expandable": true,
    "child_filters": [
      "document_schema"
    ],
    "filters": [
      "Bucket/**"
    ],
    "categories": [
      "Deduplication"
    ],
    "key": "enrichment_meta",
    "sub_keys": [
      "batch_enrichment_meta"
    ],
    "schema": [
      {
        "templateOptions": {
          "required": true,
          "pattern": "[a-zA-Z0-9_]+",
          "label": "Unique Element Name",
          "placeholder": "A Short Name For This Enrichment Element (Alphanumeric/_ only, no spaces - used for dependencies etc)"
        },
        "key": "_short_name",
        "type": "horizontalInput"
      }
    ],
    "building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  var obj = { \n    name: template.element.short_name,\n    entry_point: \"com.ikanow.aleph2.analytics.services.DeduplicationService\",\n    config: {}\n  };\n  a2_inject_enrichment(curr_obj, obj);\n  return obj;\n}"
    },
    "post_building_function": {
      "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) {\n  \n  var obj_to_mod;\n  if (Array.isArray(curr_obj)) {\n    obj_to_mod = curr_obj[curr_obj.length - 1];\n  }\n  else if (curr_obj.config) { \n    if (curr_obj.config.enrich_pipeline) {\n\t    obj_to_mod = curr_obj.config.enrich_pipeline[curr_obj.config.enrich_pipeline.length - 1];      \n  \t}\n  \telse obj_to_mod = curr_obj.config; \n  } \n  else obj_to_mod = curr_obj;\n  \n  obj_to_mod.config.doc_schema_override = obj_to_mod.document_schema;\n  obj_to_mod.document_schema = undefined;\n}"
    }
  }
]