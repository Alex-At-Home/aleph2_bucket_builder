{
	"templates": [
	{
		"display_name": "Generic Harvester",
		"key": "generic_harvester",
		"categories": ["Harvester"],
		"filters": ["Bucket"],
		"expandable": false,
		"form_info": "For advanced users: create an empty Harvester Config that users can build with the form; and configure by writing raw JSON",
		"schema": [
		{
			"key": "harvest_technology_name_or_id",
			"type": "horizontalInput",
			"templateOptions": {
				"label": "Technology Library Name",
				"placeholder": "The path to the technology, eg /app/aleph2/library/harvester.jar",
				"required": true
			}			
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "poll_frequency",
			"type": "horizontalInput",
			"templateOptions": {
				"label": "Poll Frequency",
				"placeholder": "Human readable frequency (eg '10min', '1 day') for how often this harvester is polled",
				"required": false
			}			
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "show_advanced",
			"type": "checkbox",
			"templateOptions": {
				"label": "Show Advanced Options"
			}
		},
		{
			"key": "module_name_or_id",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Technology Module Name",
				"placeholder": "For harvesters with pluggable modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
				"required": false
			}
		},
		{
			"key": "entry_point",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Entry Point Override",
				"placeholder": "For harvest modules with multiple entry points, specifies the JVM class to execute, eg com.ikanow.aleph2.harvest.module.Module1EntryPoint",
				"required": false
			}
		},
		{
			"key": "library_names_or_ids",
			"type": "multiInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Additional Library Modules",
				"inputOptions": {
					"type": "input",
					"templateOptions": {
						"label": "Technology Module Name",
						"placeholder": "For harvesters that need additional library modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
						"required": false
					}
				}
			}
		},
		{
			"key": "node_rules",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Node rules",
				"placeholder": "Comma-separated list of rules determining on which nodes this harvester will run",
				"required": false
			}
		},
		{
			"key": "multi_node_enabled",
			"type": "horizontalCheckbox",
			"defaultValue": false,
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Harvester multi-node enabled",
				"required": false
			}
		},
		{
			"key": "lock_to_nodes",
			"type": "horizontalCheckbox",
			"defaultValue": true,
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Lock harvester to the same node/set of nodes (recommend leave as true)",
				"required": false
			}
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "config",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Harvest Configuration JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  var pf = template.element.form_model.poll_frequency; \n  curr_obj.poll_frequency = (pf || '').length > 0 ? pf : undefined; \n  curr_obj.harvest_technology_name_or_id = template.element.form_model.harvest_technology_name_or_id; \n  if (template.element.form_model.node_rules && (template.element.form_model.node_rules.length > 0)) {\n\t  curr_obj.node_rules = (template.element.form_model.node_rules || '').replace(/\\s*,\\s*/g, \",\").split(\",\");\n}\n\t  curr_obj.multi_node_enabled = template.element.form_model.multi_node_enabled;\n  curr_obj.lock_to_nodes = template.element.form_model.lock_to_nodes;\n  curr_obj.harvest_configs = [\n    {\n      module_name_or_id: template.element.form_model.module_name_or_id, \n      library_names_or_ids: template.element.form_model.library_names_or_ids,\n      entry_point: template.element.form_model.entry_point, \n      config: JSON.parse(template.element.form_model.config || '{}') \n    }]; \n}" }						
	}	
	,
	{
		"display_name": "Analytic Thread Container",
		"key": "analytic_thread",
		"categories": ["Analytics"],
		"filters": ["Bucket"],
		"expandable": true,
	
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.analytic_thread = { jobs: [] }; return curr_obj.analytic_thread; }" },
	
		"form_info": "<p>This is a container for the analytic jobs that fill the bucket with data</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n"
	},
	{
		"display_name": "Generic Analytic Job",
		"key": "analytic_job",
		"categories": ["Processing"],
		"filters": ["Bucket/analytic_thread"],
		"expandable": true,
		
		"form_info": "A streaming or batch analytic job that performs processing on input or stored data. ",
		
		"schema": [
		{
			"key": "analytic_type",
			"type": "horizontalSelect",
			"templateOptions": {
				"required": true,
				"label": "Analytic Type",
				"options": [
				{
					"name": "Batch",
					"value": "batch"
				},
				{
					"name": "Streaming",
					"value": "streaming"
				}
				]
			}
		},
		{
			"key": "dependencies",
			"type": "horizontalInput",
			"hideExpression": "model.analytic_type !== \"batch\"", 
			"templateOptions": {
				"label": "Dependencies",
				"placeholder": "A comma-separated list of dependencies on other analytic jobs",
				"required": false
			}			
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "analytic_technology_name_or_id",
			"type": "horizontalInput",
			"templateOptions": {
				"label": "Technology Library Name",
				"placeholder": "The path to the technology, eg /app/aleph2/library/analytic_technology.jar",
				"required": true
			}			
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "show_advanced",
			"type": "checkbox",
			"templateOptions": {
				"label": "Show Advanced Options"
			}
		},
		{
			"key": "module_name_or_id",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Technology Module Name",
				"placeholder": "For harvesters with pluggable modules, the path to the module, eg /app/aleph2/library/harvester_module.jar",
				"required": false
			}
		},
		{
			"key": "entry_point",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Entry Point Override",
				"placeholder": "For harvest modules with multiple entry points, specifies the JVM class to execute, eg com.ikanow.aleph2.harvest.module.Module1EntryPoint",
				"required": false
			}
		},
		{
			"key": "library_names_or_ids",
			"type": "multiInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Additional Library Modules",
				"inputOptions": {
					"type": "input",
					"templateOptions": {
						"label": "Technology Module Name",
						"placeholder": "For analytics that need additional library modules, the path to the module, eg /app/aleph2/library/analytic_module_lib.jar",
						"required": false
					}
				}
			}
		},
		{
			"key": "node_rules",
			"type": "horizontalInput",
			"hideExpression": "!model.show_advanced", 
			"templateOptions": {
				"label": "Node rules",
				"placeholder": "Comma-separated list of rules determining on which nodes this analytic job will run",
				"required": false
			}
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "config",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Analytic Job Configuration JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { \n  var new_obj = { inputs: [] };\n  new_obj.analytic_type = template.element.form_model.analytic_type; \n  if (template.element.form_model.dependencies && (template.element.form_model.dependencies.length > 0)) {\n  \tnew_obj.dependencies = (template.element.form_model.dependencies || '').replace(\"\\\\s*,\\\\s*\", \",\").split(\",\");\n  }\n  new_obj.analytic_technology_name_or_id = template.element.form_model.analytic_technology_name_or_id; \n  new_obj.module_name_or_id = template.element.form_model.module_name_or_id; \n  new_obj.entry_point = template.element.form_model.entry_point; \n  new_obj.library_names_or_ids = template.element.form_model.library_names_or_ids; \n  if (template.element.form_model.node_rules && (template.element.form_model.node_rules.length > 0)) {\n\t  new_obj.node_rules = (template.element.form_model.node_rules || '').replace(\"\\\\s*,\\\\s*\", \",\").split(\",\");\n  }\n  new_obj.config = JSON.parse(template.element.form_model.config || '{}'); \n  curr_obj.jobs.push(new_obj);\n  return new_obj;\n}" }
	},
	{
		"display_name": "Raw JSON Analytic Trigger",
		"key": "analytic_trigger",
		"categories": ["Scheduling"],
		"filters": ["Bucket/analytic_thread"],
		"expandable": false,
	
		"form_info": "For advanced users: create an empty trigger JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schedule",
			"type": "horizontalInput",
			"templateOptions": {
				"label": "Trigger Check Schedule",
				"placeholder": "Human readable frequency (eg '10min', '1 day') for how often this harvester is polled",
				"required": false
			}			
		},
		{
			"template": "<hr/>"
		},
		{
			"key": "trigger",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Analytic Thread Trigger JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.trigger_config = JSON.parse(template.element.form_model.trigger || '{}'); var pf = template.element.form_model.schedule; curr_obj.trigger_config.schedule = (pf || '').length > 0 ? pf : undefined; }" }
	},	
	{
		"display_name": "Raw JSON Global Input Config",
		"key": "analytic_input",
		"categories": ["Schema"],
		"filters": ["Bucket/analytic_thread/analytic_job"],
		"expandable": false,
	
		"form_info": "Empty JSON object used to configure the global default input configuration for all inputs in this analytic job\n",
		
		"schema": [
		{
			"key": "global_input_config",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Analytic Global Input Configuration JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.global_input_config = JSON.parse(template.element.form_model.global_input_config || '{}'); }" }
	},		
	{
		"display_name": "Raw JSON Analytic Input",
		"key": "analytic_input",
		"categories": ["Schema"],
		"filters": ["Bucket/analytic_thread/analytic_job"],
		"expandable": false,
	
		"form_info": "Empty JSON object used to configure an input for this analytic job\n",
		
		"schema": [
		{
			"key": "input",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Analytic Input JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.inputs.push(JSON.parse(template.element.form_model.input || '{}')); }" }
	},		
	{
		"display_name": "Raw JSON Analytic Output",
		"key": "analytic_output",
		"categories": ["Schema"],
		"filters": ["Bucket/analytic_thread/analytic_job"],
		"expandable": false,
	
		"form_info": "Empty JSON object used to configure a single output for this analytic job\n",
		
		"schema": [
		{
			"key": "output",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Analytic Output JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.output = JSON.parse(template.element.form_model.output || '{}'); }" }
	}		
	
	,
	{
		"display_name": "Data Schema Container",
		"key": "data_schema",
		"categories": ["Metadata"],
		"filters": ["Bucket"],
		"expandable": true,
	
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.data_schema = {}; return curr_obj.data_schema; }" },
	
		"form_info": "<p>This is a container for the data schema for the different attributes of the stored data</p>\n<p>It has no attributes of its own - instead expand it using the <a class=\"glyphicon glyphicon-fullscreen\"></a> icon\n and then add the desired attributes from those available.\n</p>\n"
	}
	,
	{
		"display_name": "Raw JSON Search Index Schema",
		"key": "search_index_schema",
		"categories": ["Schema"],
		"filters": ["Bucket/data_schema"],
		"expandable": false,
	
		"form_info": "For advanced users: create an empty search index schema JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schema",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Search Index Schema JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.search_index_schema = JSON.parse(template.element.form_model.schema || '{}'); }" }
	},	
	{
		"display_name": "Raw JSON Temporal Schema",
		"key": "temporal_schema",
		"categories": ["Schema"],
		"filters": ["Bucket/data_schema"],
		"expandable": false,
	
		"form_info": "For advanced users: create an empty temporal schema JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schema",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Temporal Schema JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.temporal_schema = JSON.parse(template.element.form_model.schema || '{}'); }" }
	},	
	{
		"display_name": "Raw JSON Columnar Schema",
		"key": "columnar_schema",
		"categories": ["Schema"],
		"filters": ["Bucket/data_schema"],
		"expandable": false,
	
		"form_info": "For advanced users: create an empty columnar schema JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schema",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Columnar Schema JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.columnar_schema = JSON.parse(template.element.form_model.schema || '{}'); }" }
	},
	{
		"display_name": "Raw JSON Storage Schema",
		"key": "storage_schema",
		"categories": ["Schema"],
		"filters": ["Bucket/data_schema"],
		"expandable": true,
	
		"form_info": "For advanced users: create an empty storage schema JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schema",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Storage Schema JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.storage_schema = JSON.parse(template.element.form_model.schema || '{}'); return curr_obj.storage_schema; }" }
	},	
	{
		"display_name": "Raw JSON Document Schema",
		"key": "document_schema",
		"categories": ["Schema"],
		"filters": ["Bucket/data_schema"],
		"expandable": true,
	
		"form_info": "For advanced users: create an empty document schema JSON object that can be Raw JSON to provide the desired functionality\n",
		
		"schema": [
		{
			"key": "schema",
			"type": "code_input",
			"defaultValue": "{\n}",
			"templateOptions": {
				"label": "Document Schema JSON",
				"codemirror": {
					"lineNumbers": true,
					"smartIndent": true,
					"mode": "javascript"
				}
			}
		}
		],
		
		"building_function": { "$fn": "function(errs, template, curr_obj, all_templates, root_obj, hierarchy, rows, cols) { curr_obj.document_schema = JSON.parse(template.element.form_model.schema || '{}'); return curr_obj.document_schema; }" }
	}		
	]
}